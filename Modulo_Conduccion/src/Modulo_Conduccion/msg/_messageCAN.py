"""autogenerated by genpy from Modulo_Conduccion/messageCAN.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class messageCAN(genpy.Message):
  _md5sum = "02717f479fdfd6d478732dcace63ec89"
  _type = "Modulo_Conduccion/messageCAN"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """# Single scan from a Bus CAN

int8 senal


# Señal 1 - ELECTRONIC TRANSMISSION CONTROLLER1
string opcion_etc1		#string
float64 revoluciones_etc1	#double
float64 porcentaje_etc1		#double
float64 revoluciones2_etc1	#double


# Señal 2 - ELECTRONIC ENGINE CONTROLLER1
float64 revoluciones_eec1	#double
float64 porcentaje_eec1		#double (entero)


# Señal 3 - ELECTRONIC TRANSMISSION CONTROLLER2
float64 marcha			#double (entero)
float64 marcha_2		#double
float64 marcha_3		#double (entero)


# Señal 4 - ELECTRONIC BRAKE CONTROLLER1
string opcion_ebc1		#string
float64 porcentaje_ebc1		#double


# Señal 5 - CRUISE CONTROL VEHICULE SPEED
string opcion_ccvs		#string
float64 km_h_ccvs		#double
string opcion2_ccvs		#string
string opcion3_ccvs		#string
string opcion4_ccvs		#string
string pto_state_ccvs		#string


# Señal 6 - AUXILIARY STATE
string opcion_aux		#string
string opcion2_aux		#string
string opcion3_aux		#string


# Señal 7 - ELECTRONIC ENGINE CONTROLLER2
string opcion_eec2		#string
string opcion2_eec2		#string
float64 porcentaje_eec2		#double
float64 porcentaje2_eec2	#double


# Señal 8 - ENGINE TEMPERATURE
float64 grados_et		#double (entero)
float64 grados2_et		#double (entero)
float64 grados3_et		#double


# Señal 9 - ENGINE FLUID
float64 bares_ef		#double


# Señal 10 - SUPPLY PRESSURE 
float64 bares_sp		#double
float64 bares2_sp		#double
float64 bares3_sp		#double
float64 bares4_sp		#double
float64 bares5_sp		#double
float64 bares6_sp		#double


# Señal 11 - AMBIENT CONDITIONS
float64 bares_ac		#double
float64 grados_ac		#double


# Señal 12 - VEHICULE DISTANCE HIGH RESOLUTION
float64 kilometros_vdhr		#double


# Señal 13 - VEHICULE WEIGHT
string axle			#string
float64 kilogramos_vheacs	#double


# Señal 14 - ENGINE HOURS
float64 horas			#double


# Señal 15 - TACOGRAPH
string driverWorking1		#string
string driverWorking2		#string
string opcion_t			#string
string driverTime1		#string
string opcion2_t		#string
string opcion3_t		#string
string driverTime2		#string
string opcion4_t		#string
string opcion5_t		#string
string opcion6_t		#string
string opcion7_t		#string
float64 km_h_t			#double


# Señal 16 - ELECTRONIC RETARDER CONTROLLER EXHAUST
float64 porcentaje_erc		#double (entero)


# Señal 17 - AUX STAT
string opcion_auxstat		#string
string opcion2_auxstat		#string


# Señal 18 - FUEL ECONOMY
float64 litros			#double
float64 km_l			#double


# Señal 19 - ELECTRONIC TRANSMISSION CONTROLLER3 
string opcion_etc3		#string
string opcion2_etc3		#string
string pto1state		#string
string pto2state		#string
string nmvstate			#string



"""
  __slots__ = ['senal','opcion_etc1','revoluciones_etc1','porcentaje_etc1','revoluciones2_etc1','revoluciones_eec1','porcentaje_eec1','marcha','marcha_2','marcha_3','opcion_ebc1','porcentaje_ebc1','opcion_ccvs','km_h_ccvs','opcion2_ccvs','opcion3_ccvs','opcion4_ccvs','pto_state_ccvs','opcion_aux','opcion2_aux','opcion3_aux','opcion_eec2','opcion2_eec2','porcentaje_eec2','porcentaje2_eec2','grados_et','grados2_et','grados3_et','bares_ef','bares_sp','bares2_sp','bares3_sp','bares4_sp','bares5_sp','bares6_sp','bares_ac','grados_ac','kilometros_vdhr','axle','kilogramos_vheacs','horas','driverWorking1','driverWorking2','opcion_t','driverTime1','opcion2_t','opcion3_t','driverTime2','opcion4_t','opcion5_t','opcion6_t','opcion7_t','km_h_t','porcentaje_erc','opcion_auxstat','opcion2_auxstat','litros','km_l','opcion_etc3','opcion2_etc3','pto1state','pto2state','nmvstate']
  _slot_types = ['int8','string','float64','float64','float64','float64','float64','float64','float64','float64','string','float64','string','float64','string','string','string','string','string','string','string','string','string','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','string','float64','float64','string','string','string','string','string','string','string','string','string','string','string','float64','float64','string','string','float64','float64','string','string','string','string','string']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       senal,opcion_etc1,revoluciones_etc1,porcentaje_etc1,revoluciones2_etc1,revoluciones_eec1,porcentaje_eec1,marcha,marcha_2,marcha_3,opcion_ebc1,porcentaje_ebc1,opcion_ccvs,km_h_ccvs,opcion2_ccvs,opcion3_ccvs,opcion4_ccvs,pto_state_ccvs,opcion_aux,opcion2_aux,opcion3_aux,opcion_eec2,opcion2_eec2,porcentaje_eec2,porcentaje2_eec2,grados_et,grados2_et,grados3_et,bares_ef,bares_sp,bares2_sp,bares3_sp,bares4_sp,bares5_sp,bares6_sp,bares_ac,grados_ac,kilometros_vdhr,axle,kilogramos_vheacs,horas,driverWorking1,driverWorking2,opcion_t,driverTime1,opcion2_t,opcion3_t,driverTime2,opcion4_t,opcion5_t,opcion6_t,opcion7_t,km_h_t,porcentaje_erc,opcion_auxstat,opcion2_auxstat,litros,km_l,opcion_etc3,opcion2_etc3,pto1state,pto2state,nmvstate

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(messageCAN, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.senal is None:
        self.senal = 0
      if self.opcion_etc1 is None:
        self.opcion_etc1 = ''
      if self.revoluciones_etc1 is None:
        self.revoluciones_etc1 = 0.
      if self.porcentaje_etc1 is None:
        self.porcentaje_etc1 = 0.
      if self.revoluciones2_etc1 is None:
        self.revoluciones2_etc1 = 0.
      if self.revoluciones_eec1 is None:
        self.revoluciones_eec1 = 0.
      if self.porcentaje_eec1 is None:
        self.porcentaje_eec1 = 0.
      if self.marcha is None:
        self.marcha = 0.
      if self.marcha_2 is None:
        self.marcha_2 = 0.
      if self.marcha_3 is None:
        self.marcha_3 = 0.
      if self.opcion_ebc1 is None:
        self.opcion_ebc1 = ''
      if self.porcentaje_ebc1 is None:
        self.porcentaje_ebc1 = 0.
      if self.opcion_ccvs is None:
        self.opcion_ccvs = ''
      if self.km_h_ccvs is None:
        self.km_h_ccvs = 0.
      if self.opcion2_ccvs is None:
        self.opcion2_ccvs = ''
      if self.opcion3_ccvs is None:
        self.opcion3_ccvs = ''
      if self.opcion4_ccvs is None:
        self.opcion4_ccvs = ''
      if self.pto_state_ccvs is None:
        self.pto_state_ccvs = ''
      if self.opcion_aux is None:
        self.opcion_aux = ''
      if self.opcion2_aux is None:
        self.opcion2_aux = ''
      if self.opcion3_aux is None:
        self.opcion3_aux = ''
      if self.opcion_eec2 is None:
        self.opcion_eec2 = ''
      if self.opcion2_eec2 is None:
        self.opcion2_eec2 = ''
      if self.porcentaje_eec2 is None:
        self.porcentaje_eec2 = 0.
      if self.porcentaje2_eec2 is None:
        self.porcentaje2_eec2 = 0.
      if self.grados_et is None:
        self.grados_et = 0.
      if self.grados2_et is None:
        self.grados2_et = 0.
      if self.grados3_et is None:
        self.grados3_et = 0.
      if self.bares_ef is None:
        self.bares_ef = 0.
      if self.bares_sp is None:
        self.bares_sp = 0.
      if self.bares2_sp is None:
        self.bares2_sp = 0.
      if self.bares3_sp is None:
        self.bares3_sp = 0.
      if self.bares4_sp is None:
        self.bares4_sp = 0.
      if self.bares5_sp is None:
        self.bares5_sp = 0.
      if self.bares6_sp is None:
        self.bares6_sp = 0.
      if self.bares_ac is None:
        self.bares_ac = 0.
      if self.grados_ac is None:
        self.grados_ac = 0.
      if self.kilometros_vdhr is None:
        self.kilometros_vdhr = 0.
      if self.axle is None:
        self.axle = ''
      if self.kilogramos_vheacs is None:
        self.kilogramos_vheacs = 0.
      if self.horas is None:
        self.horas = 0.
      if self.driverWorking1 is None:
        self.driverWorking1 = ''
      if self.driverWorking2 is None:
        self.driverWorking2 = ''
      if self.opcion_t is None:
        self.opcion_t = ''
      if self.driverTime1 is None:
        self.driverTime1 = ''
      if self.opcion2_t is None:
        self.opcion2_t = ''
      if self.opcion3_t is None:
        self.opcion3_t = ''
      if self.driverTime2 is None:
        self.driverTime2 = ''
      if self.opcion4_t is None:
        self.opcion4_t = ''
      if self.opcion5_t is None:
        self.opcion5_t = ''
      if self.opcion6_t is None:
        self.opcion6_t = ''
      if self.opcion7_t is None:
        self.opcion7_t = ''
      if self.km_h_t is None:
        self.km_h_t = 0.
      if self.porcentaje_erc is None:
        self.porcentaje_erc = 0.
      if self.opcion_auxstat is None:
        self.opcion_auxstat = ''
      if self.opcion2_auxstat is None:
        self.opcion2_auxstat = ''
      if self.litros is None:
        self.litros = 0.
      if self.km_l is None:
        self.km_l = 0.
      if self.opcion_etc3 is None:
        self.opcion_etc3 = ''
      if self.opcion2_etc3 is None:
        self.opcion2_etc3 = ''
      if self.pto1state is None:
        self.pto1state = ''
      if self.pto2state is None:
        self.pto2state = ''
      if self.nmvstate is None:
        self.nmvstate = ''
    else:
      self.senal = 0
      self.opcion_etc1 = ''
      self.revoluciones_etc1 = 0.
      self.porcentaje_etc1 = 0.
      self.revoluciones2_etc1 = 0.
      self.revoluciones_eec1 = 0.
      self.porcentaje_eec1 = 0.
      self.marcha = 0.
      self.marcha_2 = 0.
      self.marcha_3 = 0.
      self.opcion_ebc1 = ''
      self.porcentaje_ebc1 = 0.
      self.opcion_ccvs = ''
      self.km_h_ccvs = 0.
      self.opcion2_ccvs = ''
      self.opcion3_ccvs = ''
      self.opcion4_ccvs = ''
      self.pto_state_ccvs = ''
      self.opcion_aux = ''
      self.opcion2_aux = ''
      self.opcion3_aux = ''
      self.opcion_eec2 = ''
      self.opcion2_eec2 = ''
      self.porcentaje_eec2 = 0.
      self.porcentaje2_eec2 = 0.
      self.grados_et = 0.
      self.grados2_et = 0.
      self.grados3_et = 0.
      self.bares_ef = 0.
      self.bares_sp = 0.
      self.bares2_sp = 0.
      self.bares3_sp = 0.
      self.bares4_sp = 0.
      self.bares5_sp = 0.
      self.bares6_sp = 0.
      self.bares_ac = 0.
      self.grados_ac = 0.
      self.kilometros_vdhr = 0.
      self.axle = ''
      self.kilogramos_vheacs = 0.
      self.horas = 0.
      self.driverWorking1 = ''
      self.driverWorking2 = ''
      self.opcion_t = ''
      self.driverTime1 = ''
      self.opcion2_t = ''
      self.opcion3_t = ''
      self.driverTime2 = ''
      self.opcion4_t = ''
      self.opcion5_t = ''
      self.opcion6_t = ''
      self.opcion7_t = ''
      self.km_h_t = 0.
      self.porcentaje_erc = 0.
      self.opcion_auxstat = ''
      self.opcion2_auxstat = ''
      self.litros = 0.
      self.km_l = 0.
      self.opcion_etc3 = ''
      self.opcion2_etc3 = ''
      self.pto1state = ''
      self.pto2state = ''
      self.nmvstate = ''

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      buff.write(_struct_b.pack(self.senal))
      _x = self.opcion_etc1
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_8d.pack(_x.revoluciones_etc1, _x.porcentaje_etc1, _x.revoluciones2_etc1, _x.revoluciones_eec1, _x.porcentaje_eec1, _x.marcha, _x.marcha_2, _x.marcha_3))
      _x = self.opcion_ebc1
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      buff.write(_struct_d.pack(self.porcentaje_ebc1))
      _x = self.opcion_ccvs
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      buff.write(_struct_d.pack(self.km_h_ccvs))
      _x = self.opcion2_ccvs
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion3_ccvs
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion4_ccvs
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.pto_state_ccvs
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion_aux
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion2_aux
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion3_aux
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion_eec2
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion2_eec2
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_15d.pack(_x.porcentaje_eec2, _x.porcentaje2_eec2, _x.grados_et, _x.grados2_et, _x.grados3_et, _x.bares_ef, _x.bares_sp, _x.bares2_sp, _x.bares3_sp, _x.bares4_sp, _x.bares5_sp, _x.bares6_sp, _x.bares_ac, _x.grados_ac, _x.kilometros_vdhr))
      _x = self.axle
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_2d.pack(_x.kilogramos_vheacs, _x.horas))
      _x = self.driverWorking1
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.driverWorking2
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion_t
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.driverTime1
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion2_t
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion3_t
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.driverTime2
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion4_t
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion5_t
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion6_t
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion7_t
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_2d.pack(_x.km_h_t, _x.porcentaje_erc))
      _x = self.opcion_auxstat
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion2_auxstat
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_2d.pack(_x.litros, _x.km_l))
      _x = self.opcion_etc3
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion2_etc3
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.pto1state
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.pto2state
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.nmvstate
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
    except struct.error as se: self._check_types(se)
    except TypeError as te: self._check_types(te)

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      end = 0
      start = end
      end += 1
      (self.senal,) = _struct_b.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion_etc1 = str[start:end].decode('utf-8')
      else:
        self.opcion_etc1 = str[start:end]
      _x = self
      start = end
      end += 64
      (_x.revoluciones_etc1, _x.porcentaje_etc1, _x.revoluciones2_etc1, _x.revoluciones_eec1, _x.porcentaje_eec1, _x.marcha, _x.marcha_2, _x.marcha_3,) = _struct_8d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion_ebc1 = str[start:end].decode('utf-8')
      else:
        self.opcion_ebc1 = str[start:end]
      start = end
      end += 8
      (self.porcentaje_ebc1,) = _struct_d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion_ccvs = str[start:end].decode('utf-8')
      else:
        self.opcion_ccvs = str[start:end]
      start = end
      end += 8
      (self.km_h_ccvs,) = _struct_d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion2_ccvs = str[start:end].decode('utf-8')
      else:
        self.opcion2_ccvs = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion3_ccvs = str[start:end].decode('utf-8')
      else:
        self.opcion3_ccvs = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion4_ccvs = str[start:end].decode('utf-8')
      else:
        self.opcion4_ccvs = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.pto_state_ccvs = str[start:end].decode('utf-8')
      else:
        self.pto_state_ccvs = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion_aux = str[start:end].decode('utf-8')
      else:
        self.opcion_aux = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion2_aux = str[start:end].decode('utf-8')
      else:
        self.opcion2_aux = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion3_aux = str[start:end].decode('utf-8')
      else:
        self.opcion3_aux = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion_eec2 = str[start:end].decode('utf-8')
      else:
        self.opcion_eec2 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion2_eec2 = str[start:end].decode('utf-8')
      else:
        self.opcion2_eec2 = str[start:end]
      _x = self
      start = end
      end += 120
      (_x.porcentaje_eec2, _x.porcentaje2_eec2, _x.grados_et, _x.grados2_et, _x.grados3_et, _x.bares_ef, _x.bares_sp, _x.bares2_sp, _x.bares3_sp, _x.bares4_sp, _x.bares5_sp, _x.bares6_sp, _x.bares_ac, _x.grados_ac, _x.kilometros_vdhr,) = _struct_15d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.axle = str[start:end].decode('utf-8')
      else:
        self.axle = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.kilogramos_vheacs, _x.horas,) = _struct_2d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.driverWorking1 = str[start:end].decode('utf-8')
      else:
        self.driverWorking1 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.driverWorking2 = str[start:end].decode('utf-8')
      else:
        self.driverWorking2 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion_t = str[start:end].decode('utf-8')
      else:
        self.opcion_t = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.driverTime1 = str[start:end].decode('utf-8')
      else:
        self.driverTime1 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion2_t = str[start:end].decode('utf-8')
      else:
        self.opcion2_t = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion3_t = str[start:end].decode('utf-8')
      else:
        self.opcion3_t = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.driverTime2 = str[start:end].decode('utf-8')
      else:
        self.driverTime2 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion4_t = str[start:end].decode('utf-8')
      else:
        self.opcion4_t = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion5_t = str[start:end].decode('utf-8')
      else:
        self.opcion5_t = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion6_t = str[start:end].decode('utf-8')
      else:
        self.opcion6_t = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion7_t = str[start:end].decode('utf-8')
      else:
        self.opcion7_t = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.km_h_t, _x.porcentaje_erc,) = _struct_2d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion_auxstat = str[start:end].decode('utf-8')
      else:
        self.opcion_auxstat = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion2_auxstat = str[start:end].decode('utf-8')
      else:
        self.opcion2_auxstat = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.litros, _x.km_l,) = _struct_2d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion_etc3 = str[start:end].decode('utf-8')
      else:
        self.opcion_etc3 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion2_etc3 = str[start:end].decode('utf-8')
      else:
        self.opcion2_etc3 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.pto1state = str[start:end].decode('utf-8')
      else:
        self.pto1state = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.pto2state = str[start:end].decode('utf-8')
      else:
        self.pto2state = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.nmvstate = str[start:end].decode('utf-8')
      else:
        self.nmvstate = str[start:end]
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      buff.write(_struct_b.pack(self.senal))
      _x = self.opcion_etc1
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_8d.pack(_x.revoluciones_etc1, _x.porcentaje_etc1, _x.revoluciones2_etc1, _x.revoluciones_eec1, _x.porcentaje_eec1, _x.marcha, _x.marcha_2, _x.marcha_3))
      _x = self.opcion_ebc1
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      buff.write(_struct_d.pack(self.porcentaje_ebc1))
      _x = self.opcion_ccvs
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      buff.write(_struct_d.pack(self.km_h_ccvs))
      _x = self.opcion2_ccvs
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion3_ccvs
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion4_ccvs
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.pto_state_ccvs
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion_aux
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion2_aux
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion3_aux
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion_eec2
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion2_eec2
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_15d.pack(_x.porcentaje_eec2, _x.porcentaje2_eec2, _x.grados_et, _x.grados2_et, _x.grados3_et, _x.bares_ef, _x.bares_sp, _x.bares2_sp, _x.bares3_sp, _x.bares4_sp, _x.bares5_sp, _x.bares6_sp, _x.bares_ac, _x.grados_ac, _x.kilometros_vdhr))
      _x = self.axle
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_2d.pack(_x.kilogramos_vheacs, _x.horas))
      _x = self.driverWorking1
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.driverWorking2
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion_t
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.driverTime1
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion2_t
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion3_t
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.driverTime2
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion4_t
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion5_t
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion6_t
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion7_t
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_2d.pack(_x.km_h_t, _x.porcentaje_erc))
      _x = self.opcion_auxstat
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion2_auxstat
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_2d.pack(_x.litros, _x.km_l))
      _x = self.opcion_etc3
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.opcion2_etc3
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.pto1state
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.pto2state
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.nmvstate
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
    except struct.error as se: self._check_types(se)
    except TypeError as te: self._check_types(te)

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      end = 0
      start = end
      end += 1
      (self.senal,) = _struct_b.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion_etc1 = str[start:end].decode('utf-8')
      else:
        self.opcion_etc1 = str[start:end]
      _x = self
      start = end
      end += 64
      (_x.revoluciones_etc1, _x.porcentaje_etc1, _x.revoluciones2_etc1, _x.revoluciones_eec1, _x.porcentaje_eec1, _x.marcha, _x.marcha_2, _x.marcha_3,) = _struct_8d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion_ebc1 = str[start:end].decode('utf-8')
      else:
        self.opcion_ebc1 = str[start:end]
      start = end
      end += 8
      (self.porcentaje_ebc1,) = _struct_d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion_ccvs = str[start:end].decode('utf-8')
      else:
        self.opcion_ccvs = str[start:end]
      start = end
      end += 8
      (self.km_h_ccvs,) = _struct_d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion2_ccvs = str[start:end].decode('utf-8')
      else:
        self.opcion2_ccvs = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion3_ccvs = str[start:end].decode('utf-8')
      else:
        self.opcion3_ccvs = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion4_ccvs = str[start:end].decode('utf-8')
      else:
        self.opcion4_ccvs = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.pto_state_ccvs = str[start:end].decode('utf-8')
      else:
        self.pto_state_ccvs = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion_aux = str[start:end].decode('utf-8')
      else:
        self.opcion_aux = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion2_aux = str[start:end].decode('utf-8')
      else:
        self.opcion2_aux = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion3_aux = str[start:end].decode('utf-8')
      else:
        self.opcion3_aux = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion_eec2 = str[start:end].decode('utf-8')
      else:
        self.opcion_eec2 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion2_eec2 = str[start:end].decode('utf-8')
      else:
        self.opcion2_eec2 = str[start:end]
      _x = self
      start = end
      end += 120
      (_x.porcentaje_eec2, _x.porcentaje2_eec2, _x.grados_et, _x.grados2_et, _x.grados3_et, _x.bares_ef, _x.bares_sp, _x.bares2_sp, _x.bares3_sp, _x.bares4_sp, _x.bares5_sp, _x.bares6_sp, _x.bares_ac, _x.grados_ac, _x.kilometros_vdhr,) = _struct_15d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.axle = str[start:end].decode('utf-8')
      else:
        self.axle = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.kilogramos_vheacs, _x.horas,) = _struct_2d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.driverWorking1 = str[start:end].decode('utf-8')
      else:
        self.driverWorking1 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.driverWorking2 = str[start:end].decode('utf-8')
      else:
        self.driverWorking2 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion_t = str[start:end].decode('utf-8')
      else:
        self.opcion_t = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.driverTime1 = str[start:end].decode('utf-8')
      else:
        self.driverTime1 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion2_t = str[start:end].decode('utf-8')
      else:
        self.opcion2_t = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion3_t = str[start:end].decode('utf-8')
      else:
        self.opcion3_t = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.driverTime2 = str[start:end].decode('utf-8')
      else:
        self.driverTime2 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion4_t = str[start:end].decode('utf-8')
      else:
        self.opcion4_t = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion5_t = str[start:end].decode('utf-8')
      else:
        self.opcion5_t = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion6_t = str[start:end].decode('utf-8')
      else:
        self.opcion6_t = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion7_t = str[start:end].decode('utf-8')
      else:
        self.opcion7_t = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.km_h_t, _x.porcentaje_erc,) = _struct_2d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion_auxstat = str[start:end].decode('utf-8')
      else:
        self.opcion_auxstat = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion2_auxstat = str[start:end].decode('utf-8')
      else:
        self.opcion2_auxstat = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.litros, _x.km_l,) = _struct_2d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion_etc3 = str[start:end].decode('utf-8')
      else:
        self.opcion_etc3 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.opcion2_etc3 = str[start:end].decode('utf-8')
      else:
        self.opcion2_etc3 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.pto1state = str[start:end].decode('utf-8')
      else:
        self.pto1state = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.pto2state = str[start:end].decode('utf-8')
      else:
        self.pto2state = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.nmvstate = str[start:end].decode('utf-8')
      else:
        self.nmvstate = str[start:end]
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
_struct_2d = struct.Struct("<2d")
_struct_b = struct.Struct("<b")
_struct_d = struct.Struct("<d")
_struct_8d = struct.Struct("<8d")
_struct_15d = struct.Struct("<15d")
