/* Auto-generated by genmsg_cpp for file /home/atica/catkin_ws/src/CITIUS/CITIUS_Control_Driving/msg/msg_vehicleInfo.msg */
#ifndef CITIUS_CONTROL_DRIVING_MESSAGE_MSG_VEHICLEINFO_H
#define CITIUS_CONTROL_DRIVING_MESSAGE_MSG_VEHICLEINFO_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"


namespace CITIUS_Control_Driving
{
template <class ContainerAllocator>
struct msg_vehicleInfo_ {
  typedef msg_vehicleInfo_<ContainerAllocator> Type;

  msg_vehicleInfo_()
  : steering(0)
  , thottle(0)
  , brake(0)
  , parkingBrake(false)
  , gear(0)
  , speed(0)
  , motorRPM(0)
  , motorTemperature(0)
  , lights(false)
  , blinkerLeft(false)
  , blinkerRight(false)
  , dipss(false)
  , dipsr(false)
  , dipsp(false)
  , klaxon(false)
  {
  }

  msg_vehicleInfo_(const ContainerAllocator& _alloc)
  : steering(0)
  , thottle(0)
  , brake(0)
  , parkingBrake(false)
  , gear(0)
  , speed(0)
  , motorRPM(0)
  , motorTemperature(0)
  , lights(false)
  , blinkerLeft(false)
  , blinkerRight(false)
  , dipss(false)
  , dipsr(false)
  , dipsp(false)
  , klaxon(false)
  {
  }

  typedef int16_t _steering_type;
  int16_t steering;

  typedef int16_t _thottle_type;
  int16_t thottle;

  typedef int16_t _brake_type;
  int16_t brake;

  typedef uint8_t _parkingBrake_type;
  uint8_t parkingBrake;

  typedef uint8_t _gear_type;
  uint8_t gear;

  typedef uint16_t _speed_type;
  uint16_t speed;

  typedef int16_t _motorRPM_type;
  int16_t motorRPM;

  typedef int16_t _motorTemperature_type;
  int16_t motorTemperature;

  typedef uint8_t _lights_type;
  uint8_t lights;

  typedef uint8_t _blinkerLeft_type;
  uint8_t blinkerLeft;

  typedef uint8_t _blinkerRight_type;
  uint8_t blinkerRight;

  typedef uint8_t _dipss_type;
  uint8_t dipss;

  typedef uint8_t _dipsr_type;
  uint8_t dipsr;

  typedef uint8_t _dipsp_type;
  uint8_t dipsp;

  typedef uint8_t _klaxon_type;
  uint8_t klaxon;


  typedef boost::shared_ptr< ::CITIUS_Control_Driving::msg_vehicleInfo_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::CITIUS_Control_Driving::msg_vehicleInfo_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct msg_vehicleInfo
typedef  ::CITIUS_Control_Driving::msg_vehicleInfo_<std::allocator<void> > msg_vehicleInfo;

typedef boost::shared_ptr< ::CITIUS_Control_Driving::msg_vehicleInfo> msg_vehicleInfoPtr;
typedef boost::shared_ptr< ::CITIUS_Control_Driving::msg_vehicleInfo const> msg_vehicleInfoConstPtr;


template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const  ::CITIUS_Control_Driving::msg_vehicleInfo_<ContainerAllocator> & v)
{
  ros::message_operations::Printer< ::CITIUS_Control_Driving::msg_vehicleInfo_<ContainerAllocator> >::stream(s, "", v);
  return s;}

} // namespace CITIUS_Control_Driving

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::CITIUS_Control_Driving::msg_vehicleInfo_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::CITIUS_Control_Driving::msg_vehicleInfo_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::CITIUS_Control_Driving::msg_vehicleInfo_<ContainerAllocator> > {
  static const char* value() 
  {
    return "f5ad468e30e0eec9c9f9d0323c8e4eca";
  }

  static const char* value(const  ::CITIUS_Control_Driving::msg_vehicleInfo_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0xf5ad468e30e0eec9ULL;
  static const uint64_t static_value2 = 0xc9f9d0323c8e4ecaULL;
};

template<class ContainerAllocator>
struct DataType< ::CITIUS_Control_Driving::msg_vehicleInfo_<ContainerAllocator> > {
  static const char* value() 
  {
    return "CITIUS_Control_Driving/msg_vehicleInfo";
  }

  static const char* value(const  ::CITIUS_Control_Driving::msg_vehicleInfo_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::CITIUS_Control_Driving::msg_vehicleInfo_<ContainerAllocator> > {
  static const char* value() 
  {
    return "int16 steering\n\
int16 thottle\n\
int16 brake\n\
bool parkingBrake\n\
uint8 gear\n\
uint16 speed\n\
int16 motorRPM\n\
int16 motorTemperature\n\
bool lights\n\
bool blinkerLeft\n\
bool blinkerRight\n\
bool dipss\n\
bool dipsr\n\
bool dipsp\n\
bool klaxon\n\
";
  }

  static const char* value(const  ::CITIUS_Control_Driving::msg_vehicleInfo_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator> struct IsFixedSize< ::CITIUS_Control_Driving::msg_vehicleInfo_<ContainerAllocator> > : public TrueType {};
} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::CITIUS_Control_Driving::msg_vehicleInfo_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.steering);
    stream.next(m.thottle);
    stream.next(m.brake);
    stream.next(m.parkingBrake);
    stream.next(m.gear);
    stream.next(m.speed);
    stream.next(m.motorRPM);
    stream.next(m.motorTemperature);
    stream.next(m.lights);
    stream.next(m.blinkerLeft);
    stream.next(m.blinkerRight);
    stream.next(m.dipss);
    stream.next(m.dipsr);
    stream.next(m.dipsp);
    stream.next(m.klaxon);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct msg_vehicleInfo_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::CITIUS_Control_Driving::msg_vehicleInfo_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const  ::CITIUS_Control_Driving::msg_vehicleInfo_<ContainerAllocator> & v) 
  {
    s << indent << "steering: ";
    Printer<int16_t>::stream(s, indent + "  ", v.steering);
    s << indent << "thottle: ";
    Printer<int16_t>::stream(s, indent + "  ", v.thottle);
    s << indent << "brake: ";
    Printer<int16_t>::stream(s, indent + "  ", v.brake);
    s << indent << "parkingBrake: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.parkingBrake);
    s << indent << "gear: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.gear);
    s << indent << "speed: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.speed);
    s << indent << "motorRPM: ";
    Printer<int16_t>::stream(s, indent + "  ", v.motorRPM);
    s << indent << "motorTemperature: ";
    Printer<int16_t>::stream(s, indent + "  ", v.motorTemperature);
    s << indent << "lights: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.lights);
    s << indent << "blinkerLeft: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.blinkerLeft);
    s << indent << "blinkerRight: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.blinkerRight);
    s << indent << "dipss: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.dipss);
    s << indent << "dipsr: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.dipsr);
    s << indent << "dipsp: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.dipsp);
    s << indent << "klaxon: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.klaxon);
  }
};


} // namespace message_operations
} // namespace ros

#endif // CITIUS_CONTROL_DRIVING_MESSAGE_MSG_VEHICLEINFO_H

